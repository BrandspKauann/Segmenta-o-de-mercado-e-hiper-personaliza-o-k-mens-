# -*- coding: utf-8 -*-
"""Marketing - Segmentação de clientes

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fWOrJDR-g19a5888OX7bEimdrqFTlezy
"""

import pandas as pd
from io import StringIO
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt
import numpy as np
import warnings

# Ignorar warnings de convergência do K-Means para um código mais limpo
warnings.filterwarnings('ignore')

# Dados simulados: 15 Clientes
# Renda (Milhares R$), Frequência (Compras/Mês), Valor Médio Compra (R$)
dados_clientes_str = """
ID_Cliente,Renda_K,Frequencia_Compras,Valor_Medio_R
C01,35,1,150
C02,40,3,200
C03,80,10,50
C04,120,8,60
C05,45,2,180
C06,130,9,55
C07,30,1,100
C08,90,11,45
C09,50,4,220
C10,110,7,70
C11,32,2,130
C12,100,10,48
C13,55,5,250
C14,125,8,65
C15,48,3,190
"""
df_clientes = pd.read_csv(StringIO(dados_clientes_str))

# 1. Definir as Features para Segmentação
X = df_clientes[['Renda_K', 'Frequencia_Compras', 'Valor_Medio_R']]

# 2. Padronização dos Dados (Scaling)
# Crucial para K-Means: garante que a Renda não domine a Frequência e o Valor.
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

print("--- Dados Brutos (Head) ---")
print(df_clientes.head())
print("\n--- Dados Padronizados (Scaled) ---")
print(pd.DataFrame(X_scaled, columns=X.columns).head())

# Determinar o melhor número de clusters (K) usando o Método do Cotovelo
# WCSS (Within-Cluster Sum of Squares): a soma das distâncias quadradas dentro do cluster.
wcss = []
max_k = 8 # Testar até 8 clusters
for i in range(1, max_k):
    kmeans = KMeans(n_clusters=i, init='k-means++', random_state=42)
    kmeans.fit(X_scaled)
    wcss.append(kmeans.inertia_) # inertia_ é o WCSS

# Plotagem do gráfico (simulada por interpretação de código)
# Normalmente, aqui você procuraria o "cotovelo" no gráfico.
print("\n--- Método do Cotovelo (Interpretação) ---")
print("O 'cotovelo' (ponto de inflexão) mais provável na WCSS é onde o ganho de adicionar mais um cluster se torna marginal.")

# Com base na simulação, escolheremos K=3, que é comum em segmentação (Ex: Premium, Intermediário, Econômico)
K_otimizado = 3
print(f"Número de Clusters Escolhido (K): {K_otimizado}")

# 1. Aplicar K-Means com K=3
kmeans = KMeans(n_clusters=K_otimizado, init='k-means++', random_state=42)
cluster_labels = kmeans.fit_predict(X_scaled)

# 2. Adicionar os Rótulos ao DataFrame Original
df_clientes['Cluster'] = cluster_labels

# 3. Analisar as Características Médias de Cada Cluster
analise_grupos = df_clientes.groupby('Cluster').agg({
    'Renda_K': 'mean',
    'Frequencia_Compras': 'mean',
    'Valor_Medio_R': 'mean',
    'ID_Cliente': 'count' # Contagem de clientes em cada grupo
}).rename(columns={'ID_Cliente': 'Total_Clientes'})

print("\n--- Análise dos Grupos (Características Médias) ---")
print(analise_grupos.round(2))

# 4. Atribuição de Nomes de Marketing (Interpretação de Negócio)
print("\n--- Nomes Sugeridos para os Segmentos (Interpretação) ---")
# Exemplo de interpretação
# Cluster 2 (Renda Alta, Frequência Alta, Valor Médio Baixo): Clientes que compram muito, mas produtos de baixo valor.
# Cluster 1 (Renda Baixa, Frequência Baixa, Valor Médio Alto): Clientes que compram pouco, mas produtos caros.
# Cluster 0 (Renda Média, Frequência Média, Valor Médio Alto): Clientes de maior valor geral.

print("Segmento 0: Clientes de Alto Valor (Foco em Retenção Premium)")
print("Segmento 1: Clientes de Baixa Frequência / Ticket Alto (Foco em Frequência)")
print("Segmento 2: Clientes de Alta Frequência / Ticket Baixo (Foco em Upselling)")